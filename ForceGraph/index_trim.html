<!DOCTYPE html>
<meta charset="utf-8">
<style>
</style>


<body id="container" style="overflow: hidden">
<div id="searchbar" class="ui-widget">
    <input id="search">
    <button type="button" onclick="searchNode()">Search</button>
</div>
<svg id="viz"></svg>
</body>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script type='text/javascript' src="http://code.jquery.com/ui/1.11.0/jquery-ui.min.js"></script>
<link rel="stylesheet" type="text/css" href="jquery-ui-edited.css">
<link href="https://fonts.googleapis.com/css?family=Slabo+27px" rel="stylesheet">

<script>

    // -------- CONFIGURATION CONTROLLERS ----------
    var config = {
        "velocityDecay": .8,
        "linkStrength": 1,
        "linkDistance": 30,
        "charge": 150,
        "gravity": .1,
        "collision": 3,
        "display links": true,
        "solo uses in %": true,
        "node scaling":true
    };
    var gui = new dat.GUI();

    var fl = gui.addFolder('Force Layout');

    fl.open()
    var velocityDecayChanger = fl.add(config, "velocityDecay", 0, 1);
    velocityDecayChanger.onChange(function (value) {
        simulation.velocityDecay(value);
        simulation.restart()
    });
    var linkDistanceChanger = fl.add(config, "linkDistance", 0, 1000);
    linkDistanceChanger.onChange(function (value) {
        simulation.force("link").distance(value);
        simulation.alphaTarget(0.1).restart()
    });
    var linkStrengthChanger = fl.add(config, "linkStrength", 0, 1);
    linkStrengthChanger.onChange(function(value){
        var strength = function (d) {
            return value * d.value / Math.min(d.source.uses, d.target.uses);
        };
        simulation.force("link", d3.forceLink().strength(strength));
        simulation.alphaTarget(0.1).restart()
    });
    var chargeChanger = fl.add(config, "charge", 30, 300);
    chargeChanger.onChange(function (value) {
        simulation.force("charge").strength(-value);
        simulation.alphaTarget(0.4).restart()
    });
    //    var thetaChanger = fl.add(config,"theta", 0, 1);
    //    thetaChanger.onChange(function(value) {
    //        force.theta(value)
    //        force.start()
    //    });
    var collisionChanger = fl.add(config, "collision", 0, 20);
    collisionChanger.onChange(function (value) {
        simulation.force("collide", d3.forceCollide().radius(function (d) {
            return value * Math.sqrt(d.uses);
        }).iterations(2));
        simulation.alphaTarget(0.4).restart()
    });

    var phiChanger = gui.add(config, "solo uses in %").listen();
    phiChanger.onChange(function () {
        // the value is used to chose which phi tu use
        simulation.restart()
    });


    //    var thresholdChanger = fl.add(config, "threshold", 0, 1);
//    thresholdChanger.onChange(function (value) {
//
//        simulation.alphaTarget(0.4).restart()
//    });


    // ------ Global variables -----------
    // color groups
    //var color = d3.scaleOrdinal(d3.schemeCategory20);

    // set SVG width, height to window size
    var w = window,
            d = document,
            e = d.documentElement,
            g = d.getElementsByTagName('body')[0],
            width = w.innerWidth || e.clientWidth || g.clientWidth,
            height = w.innerHeight || e.clientHeight || g.clientHeight;

    var svg = d3.select("svg")
            .attr("width", width)
            .attr("height", height);

    function updateWindow() {
        var width = w.innerWidth || e.clientWidth || g.clientWidth;
        var height = w.innerHeight || e.clientHeight || g.clientHeight;

        svg.attr("width", width).attr("height", height);
        backgrd.attr("width", width).attr("height", height);
    }
    window.onresize = updateWindow;

    // create a background to intercept events
    // (responds to mouse, even when transparent)
    var backgrd = svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .style("fill", "white")
            .style("opacity", 0.2)
            .style("pointer-events", "all")
            .on("click", unclick);

    var g = svg.append("g")
            .attr("class", "container");

    /////// ----------------------- FUNCTIONS ----------------


    //------------------------ ZOOM ------------------------

    function zoomed() {
//        console.log("zoomed trsfrm", d3.event.transform);
        g.attr("transform", "translate(" + d3.event.transform.x + "," + d3.event.transform.y + ")scale(" + d3.event.transform.k + ")");
    }

    var zoom = d3.zoom()
            .scaleExtent([0.2, 4])
            .on("zoom", zoomed);
    // look at zoom.extent and zoom.translateExtent
    svg.call(zoom); // why SVG and not g ?


    //------------------------ CLICK STUFF ----------------------

    function center_node(d, zoomon) {
        // Moves clicked node to center ; if zoomon true, will also zoom to on node to make it readable

        if (zoomon) {
            var scale = 3; // change to adapt to font box size !
        } else {
            var scale = d3.zoomTransform(viz).k;
        }

        var dcx = (width / 2 - d.x * scale);
        var dcy = (height / 2 - d.y * scale);


        // effectively do the transform
        g.transition()
                .duration(2000)
                .attr("transform", "translate(" + dcx + "," + dcy + ")scale(" + scale + ")");

        // update zoom object to reflect the transform, and prevent "jumping" effect when click followed by panning
        d3.select(viz).transition().duration(2000)
                .call(zoom.transform, d3.zoomIdentity.translate(dcx, dcy).scale(scale));

        fadeOtherLinks(d.name);
//        console.log("center trsfrm", d3.zoomTransform(viz));

        // DISPLAY STATS INFO -- TO BE MOVED
        console.log(d.name, "STATS");
        var co_uses = 0;

        var node_out_links = simulation.force("link").links()
                .filter( function(p) {return p.source == d} );
        for (var i=0; i < node_out_links.length; i++) {
            co_uses += node_out_links[i].value;
            console.log("is linked to: ", node_out_links[i].target.name, "with value: ", node_out_links[i].value);
        }
        var node_in_links = simulation.force("link").links()
                .filter( function(p) {return p.target == d} );
        for (var i=0; i < node_in_links.length; i++) {
            co_uses += node_in_links[i].value;
            console.log("is linked to: ", node_in_links[i].source.name, "with value: ", node_in_links[i].value);
        }
        console.log(d.name, " total usage: ", d.uses);
        console.log(d.name, " co-usage: ", co_uses);
        console.log(d.name, " solo-usage: ", d.uses-co_uses)
    }

//    function strenghten_links_to_node(d) {
//
//        var dcx = (width / 2 - d.x * scale);
//        var dcy = (height / 2 - d.y * scale);
//
//        // effectively do the transform
//        g.transition()
//                .duration(2000)
//                .attr("transform", "translate(" + dcx + "," + dcy + ")scale(" + scale + ")");
//
//        // update zoom object to reflect the transform, and prevent "jumping" effect when click followed by panning
//        d3.select(viz).transition().duration(2000)
//                .call(zoom.transform, d3.zoomIdentity.translate(dcx, dcy).scale(scale));
//
//        fadeOtherLinks(d.name);
//    }


    function get_co_uses(node){
        var node_links = simulation.force("link").links()
                .filter( function(p) {return p.source == node || p.target == node} );
        var co_uses = 0;
        for (var i=0; i < node_links.length; i++) {
            co_uses += node_links[i].value ;
        }
        return co_uses
    }

    function node_scale(uses) {
        if (config["node scaling"] == true) {
            return 10 + 10 * Math.sqrt(uses);
        }else{
            return 10 + uses;
        }
    }

    function phi(d) {

        if (config['solo uses in %'] == true) {
            // create a link_weight in [0,1] (highest percentage of co-usage among source or target of link)
            var link_weight = d.value / Math.min(d.source.uses, d.target.uses);
            // scale the weight to [0,10] and change scale with a x^2 function

        } else {
            var link_weight = d.value / Math.min(get_co_uses(d.source), get_co_uses(d.target));
            link_weight /= 2;
        }
        return 10 * Math.pow(link_weight, 2);
    }

//    if (d.source.name == 'Bello' && count < 30){  phi2(d), count++, console.log(link_weight) ; }


    var default_link_opacity = function (d) {
        var alpha =  (phi(d) > 0.6) ? 0.9 : 0;
        return  alpha;
    };

    var default_link_color = function (d) {
        var psi =  (phi(d) > 0.5) ? (10 - phi(d)) : 20;
        psi = Math.floor(psi);
        return "#"+(psi).toString(16)+(psi).toString(16)+(psi).toString(16);
    };

    /////////---------------- FORCE SIMULATION -----------------


    var simulation = d3.forceSimulation()
            .velocityDecay(config.velocityDecay)
            .force("link", d3.forceLink()
                    .distance(60)
                    .strength(function (d) {
                        return phi(d);
                    })
                    .id(function (d) { return d.name;}))
            .force("charge", d3.forceManyBody().strength(-config.charge))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide().radius(function (d) {
                return config.collision*Math.sqrt(d.uses);
            }).iterations(2));

    setTimeout(function(){
            simulation.force("link").distance(config.linkDistance);
    }, 2000);


    console.log(-config.charge);

    d3.json("Data/absolute link value/graph_links_min3.json", function (error, graph_links) {
        if (error) throw error;

        d3.json("Data/absolute link value/graph_nodes_min3.json", function (error, graph_nodes) {

            var links_on = true;
            var linksChanger = gui.add(config, "display links").listen();
            linksChanger.onChange(function (value) {
                links_on = value;
                simulation.restart()
            });

            var nodeChanger = gui.add(config, "node scaling").listen();
            nodeChanger.onChange(function () {
                g.selectAll("image")
                        .attr("width", function (d) { return node_scale(d.uses); })
                        .attr("x", function (d) {
                            return -(this.getBBox().width / 2);
                        })
                        .attr("y", function (d) {
                            return -(this.getBBox().height / 2);
                        });
            });


            var link = g.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph_links)
                    .enter().append("line")

            var count = 0;
            var node2 = g.append("g")
                    .attr("class", "nodes")
                    .selectAll("image")
                    .data(graph_nodes)
                    .enter().append("image")
                    .attr("id", function (d) {
                        return d.name;
                    })
                    .attr("xlink:href", function (d) {
                        return "Fonts/originals_cleaned_scaled/" + d.image_url;
                    })
                    .attr("width", function (d) {
                        return node_scale(d.uses);
                    })
                    .attr("height", 50) // max-height
                    .attr("x", function (d) {
                        return -(this.getBBox().width / 2);
                    })
                    .attr("y", function (d) {
                        return -(this.getBBox().height / 2);
                    })
                    .on("mouseover", function (d) {
                        d3.select(this).style("cursor", "pointer")
                    })
                    .on("mouseout", function (d) {
                        d3.select(this).style("cursor", "")
                    })
                    .on("click", function (d) {
                        console.log("node clicked!", count);
                        center_node(d, false)
                        count +=1;
                    });


            // -------- SIMULATION -------

            node2.append("title")
                    .text(function (d) {
                        return d.name;
                    });

            simulation
                    .nodes(graph_nodes)
                    .on("tick", ticked);

            simulation.force("link")
                    .links(graph_links);

            function ticked() {
                link
                        .attr("x1", function (d) {
                            return d.source.x;
                        })
                        .attr("y1", function (d) {
                            return d.source.y;
                        })
                        .attr("x2", function (d) {
                            return d.target.x;
                        })
                        .attr("y2", function (d) {
                            return d.target.y;
                        })
                        .attr("stroke-opacity", links_on ? default_link_opacity : 0)
                        .attr("stroke", default_link_color)
                        .attr("stroke-width", function (d) {
                            return phi(d);
                        }); // originally Math.sqrt(d.value);

                node2
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")";
                        }); // for the image
            }

            // --------- Autocomplete search bar (needs access to data) --------
            var optArray = [];

            for (var i = 0; i < graph_nodes.length - 1; i++) {
                optArray.push(graph_nodes[i].name);
            }

            optArray = optArray.sort();
            $(function () {
                $("#search").autocomplete({
                    source: optArray
                });
            });

        });
    });

    // --------- More functions --------

    function searchNode() {
        //find the node
        var selectedVal = document.getElementById('search').value;
        var node = svg.selectAll("image");

        if (selectedVal == "none") {
            return
            // sth (eg. flash red search box)
        } else {
            var selected = node.filter(function (d) {
                return d.name == selectedVal;
            });
            center_node(selected.datum(), true);
            fadeOtherLinks(selectedVal);
        }
    }

    //select all links NOT related to the font name and fade
    function fadeOtherLinks(name) {
        var fade_links = g.selectAll("line").filter(function (d) {
            return name !== d.source.name && name !== d.target.name;
        });

        svg.selectAll("line").transition().duration(1000).style('opacity', default_link_opacity);
        last_link_selection = fade_links;
        fade_links.transition().duration(1000).style('opacity', 0);
    }

    var last_link_selection = g.selectAll("line"); // initialized full
    console.log(last_link_selection);

    function unclick() {
        console.log("unclick")
        last_link_selection
                .transition().duration(1000)
                .style("opacity", last_link_selection.style("opacity") == default_link_opacity ? 0 : default_link_opacity);
    }


</script>
