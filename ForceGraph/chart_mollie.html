

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>

  <style>

 /* #chart {
    border: solid 5px red ;
  }*/

  .link {
    stroke: #ccc;
  }

  .node text {
    pointer-events: none;
    font: 10px sans-serif;
  }

  </style>

  <script>

  var isiOS = false;
  var agent = navigator.userAgent.toLowerCase();
  if(agent.indexOf('iphone') >= 0 || agent.indexOf('ipad') >= 0){
         isiOS = true;
  };


  var $chart = $('#chart'); // .width()


  // console.log(w)
  var width = w,
      height = h;

  var min_zoom = 1;
  var max_zoom = 1;

  // This is blocking the panning while dragging the nodes 
  var _blockPanning = false;

  // [x, y]
  // The lastest global translation (absolute position of the graph)-updated when drag is started or in the pan)
  var latest_global_translation = [];

  // These will be two points to calculate the difference
  var translateTwo = []; //current position of the mouse while dragging
  var translateOne = []; //where you start clicking when drag starts
  
  // Used to catch the two points (while dragging)
  var _ignoredFirstPan = false;

  // Pan:
  //   -------> last translate

  // Drag -->> ... -> anotherTranslate
  // 
  // Pan
  //   -->> New translate (translate(x2) - translate(x1) + latest_global_translation(x), ... y)


var global_graph_translation = [0, 0]; //translation that will be applied to the graph

function zoomed() {

  // Don't pan the graph while dragging the nodes
  if (_blockPanning) { return; }

  
  // Assign the current computed translation to the latest_global_translation
  if (!latest_global_translation.length) {
    latest_global_translation = d3.event.translate;
  }


  // We need two different translation points
  // When clicking the graph, first we ignore the first click and assign the current translate to
  // translate one
  // We turn on the _ignoredFirstPan and then next time (while dragging), translateTwo will be updated
  // with the current translation
  if (!_ignoredFirstPan) {
    _ignoredFirstPan = true;
    translateOne = d3.event.translate;
    return;
  } else {
    translateTwo = d3.event.translate;
  }

  // Calculate the difference between the two absolute points
  var diffTranslate = [
    translateTwo[0] - translateOne[0],
    translateTwo[1] - translateOne[1]
  ];

  // Add the difference to the latest global translation
  global_graph_translation = [
    latest_global_translation[0] + diffTranslate[0],
    latest_global_translation[1] + diffTranslate[1]
  ];
  

 // global_graph_translation is the real graph translation (x, y)
 // Relative to the initial point (0, 0)
    g.attr("transform", "translate(" + global_graph_translation + ")");
  }

  var zoom = d3.behavior.zoom()
    .scaleExtent([1, 1])
    .on("zoom", zoomed);

  var default_node_color = '#ff0000';
  var shining_node_color = '#990000';
  var text_color = 'white';
  var link_color = '#666699';

  var color = d3.scale.category20();

  var svg = d3.select("#chart").append("svg")
      .attr("width", width)
      .attr("height", height)
      .append('g')
      .call(zoom);

var rect = svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .style("fill", "none")
    .style("pointer-events", "all");

  var g = svg.append('g');

  var force = d3.layout.force()
      .gravity(0.05)
      .distance(100)
      .charge(-100)
      .size([w, h]);


  function dragstarted(d) {
    latest_global_translation = global_graph_translation;
    _blockPanning = true;
  }


function dragended(d) {
  
  _blockPanning = false;
  _ignoredFirstPan = false;
   
}

//code code code//

force.drag = force.drag()
.origin(function(d) { return d; })
.on("dragstart", dragstarted)
.on("dragend", dragended);


  d3.xhr("{{ url_for('visualization_data', interactions_filter = interactions_filter)}}")
    .header("Content-Type","application/json")
    .post(
    JSON.stringify({"fileindicator": "{{fileindicator}}"}), function(error, rawData) {
      if (error) throw error;
      var json = JSON.parse(rawData.response); 

      force
          .nodes(json.nodes)
          .links(json.links)
          .start();

      var link_scale = d3.scale.linear()
                               .domain([0, d3.max(json.links, function(d) { return (d.value);})])
                               .range([1,13]);

      var link = g.selectAll(".link")
          .data(json.links)
          .enter().append("line")
          .attr("class", "link")
          .style("stroke-width", function(d) { return link_scale(d.value); })
          .style('stroke', link_color)
          .attr("fill-opacity",.75);
          // Add an On-Click, show number of interactions below


      var node = g.selectAll(".node")
          .data(json.nodes)
          .enter().append("g")
          .attr("class", "node")
          .call(force.drag)
          .style("fill", default_node_color);


        var radius_scale = d3.scale.sqrt()
                           .domain([0, d3.max(json.nodes, function(d) { return (d.n_interactions);})])
                           .range([2,17]);

        if(isiOS){
             // single click centers node
             var centerEvent = "click";
        }
        else{
            // double click centers node
            var centerEvent = "dblclick";
        }

        var all_links = d3.selectAll('.link');
        // console.log('all links:', all_links)

        var all_nodes = d3.selectAll('.node');
        // console.log(all_nodes)
        // console.log('all nodes:', all_nodes[0])
        // console.log('length:', all_nodes[0].length)

        // var character_to_node_id = {}



        // populate_chosen_box = function(){
        var select_box = $('.chzn-select');


        select_box.empty();
        // select_box.select2({placeholder="Select a character..."})
        select_box.trigger('chosen:updated');


        var character_to_node_id = []
        var all_nodes = d3.selectAll('.node')
        // console.log(all_nodes)
        for(var i = 0; i < all_nodes[0].length; i++) {
          var option='<option value="' + all_nodes[0][i].__data__.index + '">' + all_nodes[0][i].__data__.name + '</option>';
          character_to_node_id.push(option);
          // character_to_node_id.sort();
          // select_box.append(character_to_node_id);
          }
        // character_to_node_id.sort(function(){
        //   return 
        // });
      console.log('character test',character_to_node_id)
      select_box.append("<option value='' selected='selected'></option>");
      select_box.append(character_to_node_id);


      var onClick = window.onClick = function(d, i){ 
        d3.event && d3.event.stopPropagation();
        
        _ignoredFirstPan = false;

        // console.log(this)
        // console.log('d, i, this:', d, i, this);
        var index_of_clicked_node = d.index;

        // Moves clicked node to center
        var dcx = (w/2-d.x*zoom.scale());
        var dcy = (h/2-d.y*zoom.scale());

        latest_global_translation = [dcx, dcy];
        zoom.translate([dcx,dcy]);
        g.transition()
         .duration(2000)
         .attr("transform", "translate("+ dcx + "," + dcy  + ")scale(" + zoom.scale() + ")");

        //select all links NOT related to the clicked node and fade
        var fade_links = d3.selectAll('.link').filter(function(d){
          return index_of_clicked_node !== d.source.index && index_of_clicked_node !== d.target.index;
        });
        // console.log(fade_links);
        fade_links.style('opacity', .2);

        var active_links = d3.selectAll('.link').filter(function(d){
          return index_of_clicked_node === d.source.index || index_of_clicked_node === d.target.index;
        });
        // active_links.style('stroke', 'red')
        active_links.style('opacity', .85);

        var active_link_id_list = [];
        
        active_links[0].forEach(function(link){
          active_link_id_list.push(link.__data__.target.index)
          active_link_id_list.push(link.__data__.source.index)
        });
        console.log('number of active links: ', active_link_id_list.length);
        //select all nodes not connected to the clicked node and fade
        var fade_nodes = d3.selectAll('.node').filter(function(d){
          return !active_link_id_list.includes(d.index);
        });
        fade_nodes.style('opacity', .2);

        var active_nodes = d3.selectAll('.node').filter(function(d){
          return active_link_id_list.includes(d.index);
        });
        
        console.log('number of active nodes: ', active_nodes);

        d3.selectAll('circle').filter(function(d, i){
          if(d.name === name){
            // call click event on the circle
            window.onClick(d,i);
          }
        });

        active_nodes.style('opacity', .85)
                    .transition()
                    .duration(1000)
                    .style('fill',shining_node_color)
                    .transition()
                    .duration(1000)
                    .style('fill',default_node_color);

        console.log('active links: ', active_link_id_list);
      };




      node.append('circle')
          .attr("class", "circle")
          .attr("r", function (d, i) {
            return radius_scale(d.n_interactions);
          })
          .style('opacity', .85)
          .style('stroke', 'black')
          .style('stroke-width',10)
          .style('stroke-opacity', 0.0)
          .call(force.drag)
          .on(centerEvent, onClick);

      var text_scale = d3.scale.linear()
              .domain([0, d3.max(json.nodes, function(d) { return (d.n_interactions);})])
              .range([6,16]);


      node.append("text")
          .attr("dx", 12)
          .attr("dy", ".35em")
          .attr('fill', 'black')
          .text(function(d) { return d.name })
          .style("font-size", function(d) { return text_scale(d.n_interactions) + "px"; })
          // .style('font-family',"futura-pt")
          .style('fill', text_color);

    // Make chart responsive: http://bl.ocks.org/mbostock/3355967
    var resizeTimeout = null;
    d3.select(window).on("resize", function () {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(resize, 10);
    });


    force.on("tick", function() {
      link.attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });
      node.attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; });

      node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    });
    $('#startrek-vis-interface').removeClass('content-loading');

    function resize() {
      width = $chart.width(), height = window.innerHeight;
      var svgEl = document.querySelector("svg")
      svgEl.setAttribute("width", width);
      svgEl.setAttribute("height", height);
      rect.attr("width", width).attr("height", height);
      force.size([width, height]).resume();
    }

    // window.resetGraph = function{
    //   console.log(all_nodes)
    //   // all_nodes.style('opacity', .85)
    //   // all_links.attr("fill-opacity",.75);
    // }

  })



  </script>
