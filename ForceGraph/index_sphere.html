<!DOCTYPE html>
<html>
<head>
    <title>Spherical Force-Directed Layout</title>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
    <!--<script src="/js/d3.v3.min.js"></script>-->
    <!--<script src="/js/dat-gui/build/dat.gui.js"></script> -->
    <style type="text/css">
        body {
            padding: 0;
            margin: 0;
        }
        path.node {
            stroke-width: 1.5px;
        }

        path.link {
            stroke: #999;
            fill-opacity: 0
        }
    </style>
</head>
<body>
<script type="text/javascript">
    var projections = {
        "Albers": d3.geo.albers(),
        "Azimuthal Equal Area": d3.geo.azimuthalEqualArea(),
        "Azimuthal Eqidistant": d3.geo.azimuthalEquidistant(),
        "Conic Conformal": d3.geo.conicConformal(),
        "Conic Equal Area": d3.geo.conicEqualArea(),
        "Conic Equidistant": d3.geo.conicEquidistant(),
        "Eqirectangular": d3.geo.equirectangular(),
        "Gnomonic": d3.geo.gnomonic(),
        "Mercator": d3.geo.mercator(),
        "Orthographic": d3.geo.orthographic(),
        "Stereographic": d3.geo.stereographic(),
        "Transverse Mercator": d3.geo.transverseMercator(),
    };
    var config = { "projection": "Orthographic", "clip": true, "friction": .9, "linkStrength": 1, "linkDistance": 20, "charge": 30, "gravity": .1, "theta": .8 };
    var gui = new dat.GUI();
    //var projectionChanger = gui.add(config, "projection", ['equalarea', 'equidistant', 'gnomonic', 'orthographic', 'stereographic', 'rectangular']);
    var projectionChanger = gui.add(config, "projection", Object.keys(projections));
    //http://stackoverflow.com/a/3417242
    function wrapIndex(i, i_max) {
        return ((i % i_max) + i_max) % i_max;
    }
    projectionChanger.onChange(function(value) {
        projection = projections[value]
                .scale(height/2)
                .translate([(width/2)-125, height/2])
                .clipAngle(config["clip"] ? 90 : null)

        path.projection(projections[value])
        return
        if(value == 'rectangular') {
            path = d3.geo.path().projection(function(coordinates){
                console.log(coordinates[0], coordinates[1])
                return [
                    wrapIndex(coordinates[0], width),
                    wrapIndex(coordinates[1], height),
                ];
            });
            config['clip'] = false
        } else {
            projection.mode(value)
            path = d3.geo.path().projection(projection)
        }

        force.start()
    });

    var clipChanger = gui.add(config, "clip").listen();
    clipChanger.onChange(function(value) {
        projection.clipAngle(value ? 90 : null)
        force.start()
    });

    var fl = gui.addFolder('Force Layout');
    fl.open()

    var frictionChanger = fl.add(config, "friction", 0, 1);
    frictionChanger.onChange(function(value) {
        force.friction(value)
        force.start()
    });

    var linkDistanceChanger = fl.add(config, "linkDistance", 0, 400);
    linkDistanceChanger.onChange(function(value) {
        force.linkDistance(value)
        force.start()
    });

    var linkStrengthChanger = fl.add(config, "linkStrength", 0, 1);
    linkStrengthChanger.onChange(function(value) {
        force.linkStrength(value)
        force.start()
    });

    var chargeChanger = fl.add(config,"charge", 0, 500);
    chargeChanger.onChange(function(value) {
        force.charge(-value)
        force.start()
    });

    var gravityChanger = fl.add(config,"gravity", 0, 1);
    gravityChanger.onChange(function(value) {
        force.gravity(value)
        force.start()
    });

    var thetaChanger = fl.add(config,"theta", 0, 1);
    thetaChanger.onChange(function(value) {
        force.theta(value)
        force.start()
    });

    var width = window.innerWidth,
            height = window.innerHeight - 5,
            fill = d3.scale.category20(),
            nodes = [{x: width/2, y: height/2}],
            links = [];

    var projection = projections[config["projection"]]
            .scale(height/2)
            .translate([(width/2)-125, height/2])
            .clipAngle(config["clip"] ? 90 : null)

    var path = d3.geo.path()
            .projection(projection)

    var force = d3.layout.force()
            .linkDistance(config["linkDistance"])
            .linkStrength(config["linkStrength"])
            .gravity(config["gravity"])
            .size([width, height])
            .charge(-config["charge"]);

    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(d3.behavior.drag()
                    .origin(function() { var r = projection.rotate(); return {x: 2 * r[0], y: -2 * r[1]}; })
                    .on("drag", function() { force.start(); var r = [d3.event.x / 2, -d3.event.y / 2, projection.rotate()[2]]; t0 = Date.now(); origin = r; projection.rotate(r); }))

    for(x=0;x<100;x++){
        source = nodes[~~(Math.random() * nodes.length)]
        target = {x: source.x + Math.random(), y: source.y + Math.random(), group: Math.random()}
        links.push({source: source, target: target})
        nodes.push(target)
    }

    var link = svg.selectAll("path.link")
            .data(links)
            .enter().append("path").attr("class", "link")

    var node = svg.selectAll("path.node")
            .data(nodes)
            .enter().append("path").attr("class", "node")
            .style("fill", function(d) { return fill(d.group); })
            .style("stroke", function(d) { return d3.rgb(fill(d.group)).darker(); })
            .call(force.drag);

    force
            .nodes(nodes)
            .links(links)
            .on("tick", tick)
            .start();

    function tick() {
        node.attr("d", function(d) { var p = path({"type":"Feature","geometry":{"type":"Point","coordinates":[d.x, d.y]}}); return p ? p : 'M 0 0' });
        link.attr("d", function(d) { var p = path({"type":"Feature","geometry":{"type":"LineString","coordinates":[[d.source.x, d.source.y],[d.target.x, d.target.y]]}}); return p ? p : 'M 0 0' });
    }



    // ------- Beginning of straight links
    var svg = d3.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height");


    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(function(d) { return d.name; })) // suspicious ?
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(width / 2, height / 2));

    //    var force = d3.layout.force()
    //            .linkDistance(config["linkDistance"])
    //            .linkStrength(config["linkStrength"])
    //            .gravity(config["gravity"])
    //            .size([width, height])
    //            .charge(-config["charge"]);

    d3.json("graph_links_2.json", function(error, graph_links) {

        if (error) throw error;


        d3.json("graph_nodes_2.json", function(error, graph_nodes) {

            var link = svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph_links)
                    .enter().append("line")
                    .attr("stroke-width", function(d) { return 1.5*(d.value-0.9); }); // originally Math.sqrt(d.value)

//            var node = svg.append("g")
//                    .attr("class", "nodes")
//                    .selectAll("circle")
//                    .data(graph_nodes)
//                    .enter().append("circle")
//                    .attr("r", function(d) { return Math.sqrt(2*d.uses); })
//                    .attr("fill", function(d) { return color(d.group); })
//                    .call(d3.drag()
//                    .on("start", dragstarted)
//                    .on("drag", dragged)
//                    .on("end", dragended));

            var node2 = svg.append("g")
                    .attr("class", "nodes")
                    .selectAll("image")
                    .data(graph_nodes)
                    .enter().append("image")
                    .attr("xlink:href", function(d) { return "font_pngs/"+d.image_url; })
                    .attr("width", function(d) { return 10*Math.sqrt(d.uses); })
                    .attr("height", 50) // max-height

            node2
                    .attr("x", function(d) { return -(this.getBBox().width/2);})
                    .attr("y", function(d) { return -(this.getBBox().height/2);})
                    .call(d3.drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended));


            // drag feature


//            node.append("title")
//                    .text(function(d) { return d.name; });
            node2.append("title")
                    .text(function(d) { return d.name; });

            simulation
                    .nodes(graph_nodes)
                    .on("tick", ticked);

            simulation.force("link")
                    .links(graph_links);

            function ticked() {
                link
                        .attr("x1", function(d) { return d.source.x; })
                        .attr("y1", function(d) { return d.source.y; })
                        .attr("x2", function(d) { return d.target.x; })
                        .attr("y2", function(d) { return d.target.y; });

//                node
//                      .attr("cx", function(d) { return d.x; })
//                      .attr("cy", function(d) { return d.y; });
                node2
                        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; }); // for the image

            }

//            var radius = 10;
            // BOUNDING BOX OPTION
//            function ticked() {
//                node.attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
//                        .attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });
//
//                link.attr("x1", function(d) { return d.source.x; })
//                        .attr("y1", function(d) { return d.source.y; })
//                        .attr("x2", function(d) { return d.target.x; })
//                        .attr("y2", function(d) { return d.target.y; });
//            }

        });
    });

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }



</script>
</body>
</body>
</html>