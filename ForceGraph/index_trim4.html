<!DOCTYPE html>
<meta charset="utf-8">
<style>
</style>


<body id="container" style="overflow: hidden">
<div id="searchbar" class="ui-widget">
    <input id="search">
    <button type="button" onclick="searchNode()">Search</button>
</div>
<svg id="viz"></svg>
</body>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script type='text/javascript' src="http://code.jquery.com/ui/1.11.0/jquery-ui.min.js"></script>
<link rel="stylesheet" type="text/css" href="jquery-ui-edited.css">
<link href="https://fonts.googleapis.com/css?family=Slabo+27px" rel="stylesheet">

<script>

    // -------- CONFIGURATION CONTROLLERS ----------
    var config = {
        "velocityDecay": .6,
//        "linkStrength": 1,
        "linkDistance": 100,
        "charge": 100,
        "gravity": .1,
        "collision": 0,
        "display links": true,
        "threshold": 0.20,
        "node scaling":true
    };
    var gui = new dat.GUI();

    var fl = gui.addFolder('Force Layout');

    fl.open()
    var velocityDecayChanger = fl.add(config, "velocityDecay", 0, 1);
    velocityDecayChanger.onChange(function (value) {
        simulation.velocityDecay(value);
        simulation.restart()
    });
    var linkDistanceChanger = fl.add(config, "linkDistance", 0, 1000);
    linkDistanceChanger.onChange(function (value) {
        simulation.force("link").distance(value);
        simulation.alphaTarget(0.1).restart()
    });
    //    var linkStrengthChanger = fl.add(config, "linkStrength", 0, 1);
    //    linkStrengthChanger.onChange(function(value){
    //        var strength = function (d) {
    //            return value * d.value / Math.min(d.source.uses, d.target.uses);
    //        };
    //        simulation.force("link", d3.forceLink().strength(strength));
    //        simulation.alphaTarget(0.1).restart()
    //    });
    var chargeChanger = fl.add(config, "charge", 10, 300);
    chargeChanger.onChange(function (value) {
        simulation.force("charge").strength(-value);
        simulation.alphaTarget(0.4).restart()
    });
    //    var thetaChanger = fl.add(config,"theta", 0, 1);
    //    thetaChanger.onChange(function(value) {
    //        force.theta(value)
    //        force.start()
    //    });
    var collisionChanger = fl.add(config, "collision", 0, 20);
    collisionChanger.onChange(function (value) {
        simulation.force("collide", d3.forceCollide().radius(function (d) {
            return value * Math.sqrt(d.uses);
        }).iterations(2));
        simulation.alphaTarget(0.4).restart()
    });


    // ------ Global variables -----------
    // color groups
    //var color = d3.scaleOrdinal(d3.schemeCategory20);

    // set SVG width, height to window size
    var w = window,
            d = document,
            e = d.documentElement,
            g = d.getElementsByTagName('body')[0],
            width = w.innerWidth || e.clientWidth || g.clientWidth,
            height = w.innerHeight || e.clientHeight || g.clientHeight;

    var svg = d3.select("svg")
            .attr("width", width)
            .attr("height", height);

    function updateWindow() {
        var width = w.innerWidth || e.clientWidth || g.clientWidth;
        var height = w.innerHeight || e.clientHeight || g.clientHeight;

        svg.attr("width", width).attr("height", height);
        backgrd.attr("width", width).attr("height", height);
    }
    window.onresize = updateWindow;

    // create a background to intercept events
    // (responds to mouse, even when transparent)
    var backgrd = svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .style("fill", "white")
            .style("opacity", 0.2)
            .style("pointer-events", "all")
            .on("click", unclick);

    var g = svg.append("g")
            .attr("class", "container");

    /////// ----------------------- FUNCTIONS ----------------


    //------------------------ ZOOM ------------------------

    function zoomed() {
//        console.log("zoomed trsfrm", d3.event.transform);
        g.attr("transform", "translate(" + d3.event.transform.x + "," + d3.event.transform.y + ")scale(" + d3.event.transform.k + ")");
    }

    var zoom = d3.zoom()
            .scaleExtent([0.2, 5])
            .on("zoom", zoomed);
    // look at zoom.extent and zoom.translateExtent
    svg.call(zoom); // why SVG and not g ?


    //------------------------ CLICK STUFF ----------------------

    function center_node(d, zoomon) {
        // Moves clicked node to center ; if zoomon true, will also zoom to on node to make it readable

        if (zoomon) {
            var scale = 3; // change to adapt to font box size !
        } else {
            var scale = d3.zoomTransform(viz).k;
        }

        var dcx = (width / 2 - d.x * scale);
        var dcy = (height / 2 - d.y * scale);


        // effectively do the transform
        g.transition()
                .duration(2000)
                .attr("transform", "translate(" + dcx + "," + dcy + ")scale(" + scale + ")");

        // update zoom object to reflect the transform, and prevent "jumping" effect when click followed by panning
        d3.select(viz).transition().duration(2000)
                .call(zoom.transform, d3.zoomIdentity.translate(dcx, dcy).scale(scale));

        fadeOtherLinks(d.name);
//        console.log("center trsfrm", d3.zoomTransform(viz));



        var co_uses = 0;

        var node_out_links = simulation.force("link").links()
                .filter( function(p) {return p.source == d} );
        for (var i=0; i < node_out_links.length; i++) {
            co_uses += node_out_links[i].value;
            //console.log("is linked to: ", node_out_links[i].target.name, "with value: ", node_out_links[i].value);
        }
        var node_in_links = simulation.force("link").links()
                .filter( function(p) {return p.target == d} );
        for (var i=0; i < node_in_links.length; i++) {
            co_uses += node_in_links[i].value;
            //console.log("is linked to: ", node_in_links[i].source.name, "with value: ", node_in_links[i].value);
        }

//        // DISPLAY STATS INFO -- TO BE MOVED
//        console.log(d.name, "STATS");
//        console.log(d.name, " total usage: ", d.uses);
//        console.log(d.name, " co-usage: ", co_uses);
//        console.log(d.name, " solo-usage: ", d.uses-co_uses)
    }

    //    function strenghten_links_to_node(d) {
    //
    //        var dcx = (width / 2 - d.x * scale);
    //        var dcy = (height / 2 - d.y * scale);
    //
    //        // effectively do the transform
    //        g.transition()
    //                .duration(2000)
    //                .attr("transform", "translate(" + dcx + "," + dcy + ")scale(" + scale + ")");
    //
    //        // update zoom object to reflect the transform, and prevent "jumping" effect when click followed by panning
    //        d3.select(viz).transition().duration(2000)
    //                .call(zoom.transform, d3.zoomIdentity.translate(dcx, dcy).scale(scale));
    //
    //        fadeOtherLinks(d.name);
    //    }


    function node_scale(uses) {
        if (config["node scaling"] == true) {
            return 10 + 10 * Math.sqrt(uses);
        } else {
            return 10 + uses;
        }
    }

    var i = 0;

    function phi(d) {

        var link_weight = d.value / Math.min(d.source.single_couses, d.target.single_couses);
        // change scale with a x^2 function and scale the weight to [0,10]
        if (i<30){ i++; console.log("phi1");/*console.log(Math.pow(link_weight, 2))*/}
        return 1 + 10 * Math.pow(link_weight, 2);
    }

    var phi_threshold = 1 + config.threshold;
    console.log("phi_t", phi_threshold);

    function link_strength(d){
        // try d.value > 1 or 2 instead
        var beta = (phi(d) > phi_threshold) ? phi(d) : 0.001 ;
        return beta;
    }

    function stroke_width(d){
        return phi(d) > phi_threshold ? phi(d) : 0.1;
    }


    var default_link_opacity = function (d) {
        var alpha =  (phi(d) > phi_threshold) ? 0.9 : 0.5;
        return  alpha;
    };

    var default_link_color = function (d) {
        var psi =  (phi(d) > phi_threshold) ? (10 - phi(d)) : 150;
        psi = Math.floor(psi);
        return "#"+(psi).toString(16)+(psi).toString(16)+(psi).toString(16);
    };

    /////////---------------- FORCE SIMULATION -----------------


    var simulation = d3.forceSimulation()
            .velocityDecay(config.velocityDecay)
            .force("link", d3.forceLink()
                    .distance(60)
                    .strength(function (d) {
                        return link_strength(d);
                    })
                    .id(function (d) { return d.name;}))
            .force("charge", d3.forceManyBody().strength(-config.charge))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide().radius(function (d) {
                return config.collision*Math.sqrt(d.uses);
            }).iterations(2));

//    setTimeout(function(){
//        simulation.force("link").distance(config.linkDistance);
//    }, 2000);

    d3.json("Data/absolute link value/graph_links_min9.json", function (error, graph_links) {
        if (error) throw error;

        d3.json("Data/absolute link value/graph_nodes_min9.json", function (error, graph_nodes) {

            var links_on = true;
            var linksChanger = gui.add(config, "display links").listen();
            linksChanger.onChange(function (value) {
                links_on = value;
                simulation.restart()
            });

            var nodeChanger = gui.add(config, "node scaling").listen();
            nodeChanger.onChange(function () {
                g.selectAll("image")
                        .attr("width", function (d) { return node_scale(d.uses); })
                        .attr("x", function (d) {
                            return -(this.getBBox().width / 2);
                        })
                        .attr("y", function (d) {
                            return -(this.getBBox().height / 2);
                        });
            });


            var link = g.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph_links)
                    .enter().append("line")

            var count = 0;
            var node2 = g.append("g")
                    .attr("class", "nodes")
                    .selectAll("image")
                    .data(graph_nodes)
                    .enter().append("image")
                    .attr("id", function (d) {
                        return d.name;
                    })
                    .attr("xlink:href", function (d) {
                        return "Fonts/originals_cleaned_scaled/" + d.image_url;
                    })
                    .attr("width", function (d) {
                        return node_scale(d.uses);
                    })
                    .attr("height", 50) // max-height
                    .attr("x", function (d) {
                        return -(this.getBBox().width / 2);
                    })
                    .attr("y", function (d) {
                        return -(this.getBBox().height / 2);
                    })
                    .on("mouseover", function (d) {
                        d3.select(this).style("cursor", "pointer")
                    })
                    .on("mouseout", function (d) {
                        d3.select(this).style("cursor", "")
                    })
                    .on("click", function (d) {
                        console.log("node clicked!", count);
                        center_node(d, false);
                        count +=1;
                    });



            // -------- SIMULATION -------

            //drag feature
            node2.call(d3.drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended));

            node2.append("title")
                    .text(function (d) {
                        return d.name;
                    });

            simulation
                    .nodes(graph_nodes)
                    .on("tick", ticked)
                    .on("end", function(){
                        console.log("end of simulation", simulation.nodes());
                        //console.save(simulation.nodes(), "saved_nodes.json")
                    });

            simulation.force("link")
                    .links(graph_links);


            function ticked() {
                link
                        .attr("x1", function (d) {
                            return d.source.x;
                        })
                        .attr("y1", function (d) {
                            return d.source.y;
                        })
                        .attr("x2", function (d) {
                            return d.target.x;
                        })
                        .attr("y2", function (d) {
                            return d.target.y;
                        })
                        .attr("stroke-opacity", links_on ? default_link_opacity : 0)
                        .attr("stroke", default_link_color)
                        .attr("stroke-width", stroke_width); // originally Math.sqrt(d.value);

                node2
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")";
                        }); // for the image
            }


            var phiChanger = gui.add(config, "threshold", 0,1).listen();
            phiChanger.onChange(function () {
                console.log(config.threshold); // does not change the value of phi though...
                phi_threshold = 1 + config.threshold
                simulation.force("link").strength(link_strength)
                simulation.alphaTarget(0.2).restart()
            });

            // --------- Autocomplete search bar (needs access to data) --------
            var optArray = [];

            for (var i = 0; i < graph_nodes.length - 1; i++) {
                optArray.push(graph_nodes[i].name);
            }

            optArray = optArray.sort();
            $(function () {
                $("#search").autocomplete({
                    source: optArray
                });
            });

        });
    });

    // --------- More functions --------

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function searchNode() {
        //find the node
        var selectedVal = document.getElementById('search').value;
        var node = svg.selectAll("image");

        if (selectedVal == "none") {
            return
            // sth (eg. flash red search box)
        } else {
            var selected = node.filter(function (d) {
                return d.name == selectedVal;
            });
            center_node(selected.datum(), true);
            fadeOtherLinks(selectedVal);
        }
    }

    var last_link_selection = g.selectAll("line"); // initialized full
    var last_link_opacity_status = 1; // default

    console.log('initialization', last_link_selection);

    //select all links NOT related to the font name and fade
    function fadeOtherLinks(name) {
        var fade_links = g.selectAll("line").filter(function (d) {
            return name !== d.source.name && name !== d.target.name;
        });

        // set all links to default opacity (reset old selections)
        svg.selectAll("line").transition().duration(1000).style('opacity', default_link_opacity);
        last_link_selection = fade_links;
        last_link_opacity_status = 0;

//        console.log('fadeOtherLinks', last_link_selection);
//        console.log('fadeOtherLinks status', last_link_opacity_status);

        // fade out the correct links
        fade_links.transition().duration(1000).style('opacity', 0);
    }


    function unclick() {

        console.log('background clicked', last_link_selection);

        try {
            last_link_selection
                    .transition().duration(1000)
                    .style("opacity", last_link_opacity_status == 1 ? 0 : default_link_opacity);

            last_link_opacity_status = (last_link_opacity_status == 1 ? 0 : 1)
            console.log("toggling link selection")
        }
        catch(err) {
            console.log("last_link_selection not initialized ; please click on node");
        }
    }


</script>
