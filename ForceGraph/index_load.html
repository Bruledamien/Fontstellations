<!DOCTYPE html>
<meta charset="utf-8">
<style>
</style>


<body id="body" style="overflow: hidden">
    <div id="mySidenav" class="sidenav">
        <div href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</div>

        <div id="navsearch">
            <div id="searchbar" class="ui-widget">
                <input id="search" onkeydown = "if (event.keyCode == 13)
                    document.getElementById('searchBtn').click()">
                <button id="searchBtn" type="button" type="submit" onclick="searchNode()">Search</button>
            </div>
        </div>
        <div id="navtitle" class="navmenu"> Select a font </div>
        <div id="navcontent">
            <div id="navchart">
                <svg id="piechart"></svg>
            </div>
            <a href="#">Services</a>
            <a href="#">Clients</a>
            <a href="#">Contact</a>
        </div>

    </div>
    <div id="main">
        <span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776; open</span>

        <svg id="viz"></svg>
    </div>
</body>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script type='text/javascript' src="http://code.jquery.com/ui/1.11.0/jquery-ui.min.js"></script>
<link rel="stylesheet" type="text/css" href="jquery-ui-edited.css">
<link rel="stylesheet" type="text/css" href="sidenav.css">
<link href="https://fonts.googleapis.com/css?family=Slabo+27px" rel="stylesheet">

<script>

    width = document.querySelector("#piechart").clientWidth
    height = document.querySelector("#piechart").clientHeight
    radius = Math.min(width, height) / 2;

    var piechart = d3.select("#piechart").append("g")
            .attr("width", width)
            .attr("height", height);

    piechart.append("g").attr("class", "slices");
    piechart.append("g").attr("class", "labels");
    piechart.append("g").attr("class", "lines");

    var pie = d3.pie()
            .sortValues(null) // or compare
            .value(function(d) { return d.value; });

    function compare(a, b) {
        return b - a;
    }

    var arc = d3.arc()
            .outerRadius(radius * 0.8)
            .innerRadius(0)
            .padAngle(0)
            .cornerRadius(0);

    var outerArc = d3.arc()
            .innerRadius(radius * 0.9)
            .outerRadius(radius * 0.9);

    piechart.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
    console.log("piechart init");

    //drawChart([{'name':'none', 'value':1}]);

    // -------- SIDE BAR DISPLAY  ------------------


    function openNav() {
        document.getElementById("mySidenav").style.width = "350px";
        document.getElementById("main").style.marginLeft = "350px";
    }

    function closeNav() {
        document.getElementById("mySidenav").style.width = "0";
        document.getElementById("main").style.marginLeft= "0";
    }


    // -------- CONFIGURATION CONTROLLERS ----------
    var config = {
        "velocityDecay": .3,
//        "linkStrength": 1,
        "linkDistance": 100,
        "charge": 100,
        "gravity": .1,
        "collision": 0,
        "threshold": 0.20,
        "display links": true,
        "node scaling":true
    };
    var gui = new dat.GUI();

    var fl = gui.addFolder('Force Layout');

    fl.open()
    var velocityDecayChanger = fl.add(config, "velocityDecay", 0, 1);
    velocityDecayChanger.onChange(function (value) {
        simulation.velocityDecay(value);
        simulation.restart()
    });
    var linkDistanceChanger = fl.add(config, "linkDistance", 0, 1000);
    linkDistanceChanger.onChange(function (value) {
        simulation.force("link").distance(value);
        simulation.alphaTarget(0.1).restart()
    });
    //    var linkStrengthChanger = fl.add(config, "linkStrength", 0, 1);
    //    linkStrengthChanger.onChange(function(value){
    //        var strength = function (d) {
    //            return value * d.value / Math.min(d.source.uses, d.target.uses);
    //        };
    //        simulation.force("link", d3.forceLink().strength(strength));
    //        simulation.alphaTarget(0.1).restart()
    //    });
    var chargeChanger = fl.add(config, "charge", 10, 300);
    chargeChanger.onChange(function (value) {
        simulation.force("charge").strength(-value);
        simulation.alphaTarget(0.4).restart()
    });
    //    var thetaChanger = fl.add(config,"theta", 0, 1);
    //    thetaChanger.onChange(function(value) {
    //        force.theta(value)
    //        force.start()
    //    });
    var collisionChanger = fl.add(config, "collision", 0, 20);
    collisionChanger.onChange(function (value) {
        simulation.force("collide", d3.forceCollide().radius(function (d) {
            return value * Math.sqrt(d.uses);
        }).iterations(2));
        simulation.alphaTarget(0.4).restart()
    });


    // ------ Global variables -----------
    // color groups
    //var color = d3.scaleOrdinal(d3.schemeCategory20);

    // set SVG width, height to window size
    var w = window,
            d = document,
            e = d.documentElement,
            g = d.getElementsByTagName('body')[0],
            width = w.innerWidth || e.clientWidth || g.clientWidth,
            height = w.innerHeight || e.clientHeight || g.clientHeight;

    var svg = d3.select("#viz")
            .attr("width", width)
            .attr("height", height);

    function updateWindow() {
        var width = w.innerWidth || e.clientWidth || g.clientWidth;
        var height = w.innerHeight || e.clientHeight || g.clientHeight;

        svg.attr("width", width).attr("height", height);
        backgrd.attr("width", width).attr("height", height);
    }
    window.onresize = updateWindow;

    // create a background to intercept events
    // (responds to mouse, even when transparent)
    var backgrd = svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .style("fill", "grey")
            .style("opacity", 0.2)
            .style("pointer-events", "all")
            .on("click", unclick);

    var g = svg.append("g")
            .attr("class", "container")
            .on("click", console.log("container clicked"));

    /////// ----------------------- FUNCTIONS ----------------


    //------------------------ ZOOM ------------------------

    function zoomed() {
//        console.log("zoomed trsfrm", d3.event.transform);
        g.attr("transform", "translate(" + d3.event.transform.x + "," + d3.event.transform.y + ")scale(" + d3.event.transform.k + ")");
    }

    var zoom = d3.zoom()
            .scaleExtent([0.2, 5])
            .on("zoom", zoomed);
    // look at zoom.extent and zoom.translateExtent
    svg.call(zoom); // why SVG and not g ?


    //------------------------ CLICK STUFF ----------------------

    function center_node(d, zoomon) {
        // Moves clicked node to center ; if zoomon true, will also zoom to on node to make it readable
        if (zoomon) {
            var scale = 1; // change to adapt to font box size !
        } else {
            var scale = d3.zoomTransform(viz).k;
        }

        var dcx = (width / 2 - d.x * scale);
        var dcy = (height / 2 - d.y * scale);
        // effectively do the transform
        g.transition()
                .duration(2000)
                .attr("transform", "translate(" + dcx + "," + dcy + ")scale(" + scale + ")");

        // update zoom object to reflect the transform, and prevent "jumping" effect when click followed by panning
        d3.select(viz).transition().duration(2000)
                .call(zoom.transform, d3.zoomIdentity.translate(dcx, dcy).scale(scale));

        fadeOtherLinks(d.name);
//        console.log("center trsfrm", d3.zoomTransform(viz));
        display_font_info(d)
    }

    function display_font_info(d){

        //Display selected font name
        $("#navtitle").html(d.name);

        //compute stats
        var co_uses = 0;
        var data = [];
        var node_out_links = simulation.force("link").links()
                .filter( function(p) {return p.source == d} );
        for (var i=0; i < node_out_links.length; i++) {
            co_uses += node_out_links[i].value;
            data.push({'name': node_out_links[i].target.name, 'value': node_out_links[i].value});
            //console.log("is linked to: ", node_out_links[i].target.name, "with value: ", node_out_links[i].value);
        }
        var node_in_links = simulation.force("link").links()
                .filter( function(p) {return p.target == d} );
        for (var i=0; i < node_in_links.length; i++) {
            co_uses += node_in_links[i].value;
            data.push({'name': node_in_links[i].source.name, 'value': node_in_links[i].value});
            //console.log("is linked to: ", node_in_links[i].source.name, "with value: ", node_in_links[i].value);
        }

        data.sort(function(a,b) {
                    var diff = b.value - a.value;
                    if (diff == 0){
                        return a.name - b.name;// does not work
                    } else {
                        return diff
                    }
                });
        console.log(data);

        //drawList(data)

        if (data.length > 10){
            console.log('splice', data.length);
//            var remaining_value = 0
//            for (i=11;i<data.length;i++){
//                remaining_value += data[i].value;
//            }
//            data.splice(10, data.length-10, {'name':'...', 'value':remaing_value});

            data.splice(10);
            console.log("spliced d",data)
        }

        //drawChart(data);

        // DISPLAY STATS INFO -- TO BE MOVED
//        console.log(d.name, "STATS");
//        console.log(d.name, " total usage: ", d.uses);
//        console.log(d.name, " co-usage: ", co_uses);
//        console.log(d.name, " solo-usage: ", d.uses-co_uses)

    }

    function drawChart(data) {
        console.log('draw');

        var key = function(d){ return d.data.name};

        /* ------- PIE SLICES -------*/
        var slice = piechart.select(".slices").selectAll("path.slice")
                .data(pie(data), key);

        slice.enter()
                .insert("path")
                .attr("class", "slice")
                .style("fill", function(d) { return d3.interpolateViridis(Math.random()) })
                .attr("d", arc)
                .each(function(d) { this._current = d; }); // store the initial angles

        slice
                .transition().duration(1000)
                .attrTween("d", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        return arc(interpolate(t));
                    };
                });

        slice.exit()
                .remove();

        /* ------- TEXT LABELS -------*/


        var text = piechart.select(".labels").selectAll("text")
                .data(pie(data), key);

        text.enter()
                .append("text")
                .attr("dy", ".35em")
                .text(function(d) {
                    return d.index+1; //d.data.name;
                })
                .attr("transform", function(d) {
                    var pos = outerArc.centroid(d);
                    pos[0] = radius * (midAngle(d) < Math.PI ? 1 : -1);
                    return "translate("+ pos +")";
                })
                .attr("text-anchor", function(d){
                    return midAngle(d) < Math.PI ? "start":"end"
                })
                .each(function(d) { this._current = d; });

        function midAngle(d){
            return d.startAngle + (d.endAngle - d.startAngle)/2;
        }

        text.transition().duration(1000)
                .attrTween("transform", function(d) {
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                        return "translate("+ pos +")";
                    };
                })
                .styleTween("text-anchor", function(d){
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        return midAngle(d2) < Math.PI ? "start":"end";
                    };
                });

        text.exit()
                .remove();

        /* ------- SLICE TO TEXT POLYLINES -------*/

        var polyline = piechart.select(".lines").selectAll("polyline")
                .data(pie(data), key);

        polyline.enter()
                .append("polyline")
                .attr("points", function(d) {
                        var pos = outerArc.centroid(d);
                        pos[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);
                        return [arc.centroid(d), outerArc.centroid(d), pos];
                    })
                .each(function(d) { this._current = d; });

        polyline.transition().duration(1000)
                .attrTween("points", function(d){
                    this._current = this._current || d;
                    var interpolate = d3.interpolate(this._current, d);
                    this._current = interpolate(0);
                    return function(t) {
                        var d2 = interpolate(t);
                        var pos = outerArc.centroid(d2);
                        pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);
                        return [arc.centroid(d2), outerArc.centroid(d2), pos];
                    };
                });

        polyline.exit()
                .remove();

    }



    //    function strenghten_links_to_node(d) {
    //
    //        var dcx = (width / 2 - d.x * scale);
    //        var dcy = (height / 2 - d.y * scale);
    //
    //        // effectively do the transform
    //        g.transition()
    //                .duration(2000)
    //                .attr("transform", "translate(" + dcx + "," + dcy + ")scale(" + scale + ")");
    //
    //        // update zoom object to reflect the transform, and prevent "jumping" effect when click followed by panning
    //        d3.select(viz).transition().duration(2000)
    //                .call(zoom.transform, d3.zoomIdentity.translate(dcx, dcy).scale(scale));
    //
    //        fadeOtherLinks(d.name);
    //    }


    function node_scale(uses) {
        if (config["node scaling"] == true) {
            return 10 + 10 * Math.sqrt(uses);
        } else {
            return 10 + uses;
        }
    }

    function phi(d) {
        // create a link_weight in [0,1] (highest percentage of co-usage among source or target of link)
        var link_weight = d.value / Math.min(d.source.uses, d.target.uses);
        // scale the weight to [0,10] and change scale with a x^2 function
        return 10 * Math.pow(link_weight, 2);
    }

    //    if (d.source.name == 'Bello' && count < 30){  phi2(d), count++, console.log(link_weight) ; }


    var phi_threshold = 0.6;
    var low_opacity = 0.2;

    function link_strength(d){
        // try d.value > 1 or 2 instead
        var beta = (phi(d) > phi_threshold) ? phi(d)/d.value : 0.001 ; //d.value prevents from exploding
        return beta;
    }

    function stroke_width(d){
        return phi(d) > phi_threshold ? phi(d) : 0.1;
    }


    var default_link_opacity = function (d) {
        var alpha =  (phi(d) > phi_threshold) ? 0.9 : 0.5;
        return  alpha;
    };

    var default_link_color = function (d) {
        var psi =  (phi(d) > phi_threshold) ? (10 - phi(d)) : 20;
        psi = Math.floor(psi);
        return "#"+(psi).toString(16)+(psi).toString(16)+(psi).toString(16);
    };

    /////////---------------- FORCE SIMULATION -----------------


    var simulation = d3.forceSimulation()
            .velocityDecay(config.velocityDecay)
            .force("link", d3.forceLink()
                    .distance(60)
                    .strength(function (d) {
                        return link_strength(d);
                    })
                    .id(function (d) { return d.name;}))
            .force("charge", d3.forceManyBody().strength(-config.charge))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide().radius(function (d) {
                return config.collision*Math.sqrt(d.uses);
            }).iterations(2));

//    setTimeout(function(){
//        simulation.force("link").distance(config.linkDistance);
//    }, 2000);

    d3.json("Data/absolute link value/graph_links_min3.json", function (error, graph_links) {
        if (error) throw error;

        d3.json("Data/saved_nodes.json", function (error, graph_nodes) {

            var links_on = true;
            var linksChanger = gui.add(config, "display links").listen();
            linksChanger.onChange(function (value) {
                links_on = value;
                simulation.restart()
            });

            var nodeChanger = gui.add(config, "node scaling").listen();
            nodeChanger.onChange(function () {
                g.selectAll("image")
                        .attr("width", function (d) { return node_scale(d.uses); })
                        .attr("x", function (d) {
                            return -(this.getBBox().width / 2);
                        })
                        .attr("y", function (d) {
                            return -(this.getBBox().height / 2);
                        });
            });


            var link = g.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph_links)
                    .enter().append("line")

            var count = 0;
            var node2 = g.append("g")
                    .attr("class", "nodes")
                    .selectAll("image")
                    .data(graph_nodes)
                    .enter().append("image")
                    .attr("id", function (d) {
                        return d.name;
                    })
                    .attr("xlink:href", function (d) {
                        return "Fonts/originals_cleaned_scaled/" + d.image_url;
                    })
                    .attr("width", function (d) {
                        return node_scale(d.uses);
                    })
                    .attr("height", 50) // max-height
                    .attr("x", function (d) {
                        return -(this.getBBox().width / 2);
                    })
                    .attr("y", function (d) {
                        return -(this.getBBox().height / 2);
                    })
                    .on("mouseover", function (d) {
                        d3.select(this).style("cursor", "pointer")
                    })
                    .on("mouseout", function (d) {
                        d3.select(this).style("cursor", "")
                    })
                    .on("click", function (d) {
                        console.log("node clicked!", count);
                        center_node(d, false);
                        count +=1;
                    });


            // -------- SIMULATION -------

            // drag feature
            node2.call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            node2.append("title")
                    .text(function (d) {
                        return d.name;
                    });

            simulation
                    .nodes(graph_nodes)
                    .on("tick", ticked)
                    .on("end", function(){
                        console.log("end of simulation");
                    });

            simulation.force("link")
                    .links(graph_links);


            function ticked() {
                link
                        .attr("x1", function (d) {
                            return d.source.x;
                        })
                        .attr("y1", function (d) {
                            return d.source.y;
                        })
                        .attr("x2", function (d) {
                            return d.target.x;
                        })
                        .attr("y2", function (d) {
                            return d.target.y;
                        })
                        .attr("stroke-opacity", links_on ? default_link_opacity : low_opacity)
                        .attr("stroke", default_link_color)
                        .attr("stroke-width", stroke_width); // originally Math.sqrt(d.value);

                node2
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")";
                        }); // for the image
            }


            var phiChanger = gui.add(config, "threshold", 0, 0.5).listen();
            phiChanger.onChange(function () {
                console.log(config.threshold); // does not change the value of phi though...
                phi_threshold = 1 + config.threshold
                simulation.force("link").strength(link_strength)
                simulation.alphaTarget(0.2).restart()
            });

            // --------- Autocomplete search bar (needs access to data) --------
            var optArray = [];

            for (var i = 0; i < graph_nodes.length - 1; i++) {
                optArray.push(graph_nodes[i].name);
            }

            optArray = optArray.sort();
            $(function () {
                $("#search").autocomplete({
                    source: optArray
                });
            });

        });
    });

    // --------- More functions --------

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function searchNode() {
        //find the node
        var selectedVal = document.getElementById('search').value;
        var node = svg.selectAll("image");

        if (selectedVal == "none") {
            return
            // sth (eg. flash red search box)
        } else {
            var selected = node.filter(function (d) {
                return d.name == selectedVal;
            });
            center_node(selected.datum(), true);
            fadeOtherLinks(selectedVal);
        }
    }

    var last_link_selection = g.selectAll("line"); // initialized full
    var last_link_opacity_status = 1; // default

    //console.log('initialization', last_link_selection);

    //select all links NOT related to the font name and fade
    function fadeOtherLinks(name) {
        var fade_links = g.selectAll("line").filter(function (d) {
            return name !== d.source.name && name !== d.target.name;
        });

        // set all links to default opacity (reset old selections)
        svg.selectAll("line").transition().duration(1000).style('opacity', default_link_opacity).style("stroke","red");
        last_link_selection = fade_links;
        last_link_opacity_status = 0;

//        console.log('fadeOtherLinks', last_link_selection);
//        console.log('fadeOtherLinks status', last_link_opacity_status);

        // fade out the correct links
        fade_links.transition().duration(1000).style('opacity', low_opacity).style("stroke", default_link_color);
    }


    function unclick() {

        console.log('background clicked', last_link_selection);

        try {
            last_link_selection
                    .transition().duration(1000)
                    .style("opacity", last_link_opacity_status == 1 ? low_opacity : default_link_opacity)
//                    .style("stroke", last_link_opacity_status == 1 ? default_link_color : "red");

            last_link_opacity_status = (last_link_opacity_status == 1 ? 0 : 1);
            console.log("toggling link selection")
        }
        catch(err) {
            console.log("last_link_selection not initialized ; please click on node");
        }
    }
</script>
