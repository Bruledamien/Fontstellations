<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .links line {
        stroke: #999;
        stroke-opacity: 0.6;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
    }

</style>
<svg width="2000" height="1800" ></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script>
    var projections = {
        "Albers": d3.geoAlbers(),
        "Azimuthal Equal Area": d3.geoAzimuthalEqualArea(),
        "Azimuthal Eqidistant": d3.geoAzimuthalEquidistant(),
        "Conic Conformal": d3.geoConicConformal(),
        "Conic Equal Area": d3.geoConicEqualArea(),
        "Conic Equidistant": d3.geoConicEquidistant(),
        "Eqirectangular": d3.geoEquirectangular(),
        "Gnomonic": d3.geoGnomonic(),
        "Mercator": d3.geoMercator(),
        "Orthographic": d3.geoOrthographic(),
        "Stereographic": d3.geoStereographic(),
        "Transverse Mercator": d3.geoTransverseMercator(),
    };
    var config = { "projection": "Orthographic", "clip": true, "friction": .9, "linkStrength": 1, "linkDistance": 20, "charge": 30, "gravity": .1, "theta": .8 };
    var gui = new dat.GUI();
    //var projectionChanger = gui.add(config, "projection", ['equalarea', 'equidistant', 'gnomonic', 'orthographic', 'stereographic', 'rectangular']);
    var projectionChanger = gui.add(config, "projection", Object.keys(projections));
    //http://stackoverflow.com/a/3417242
    function wrapIndex(i, i_max) {
        return ((i % i_max) + i_max) % i_max;
    }
    projectionChanger.onChange(function(value) {
        projection = projections[value]
                .scale(height/2)
                .translate([(width/2)-125, height/2])
                .clipAngle(config["clip"] ? 90 : null)

        path.projection(projections[value])
        return
        if(value == 'rectangular') {
            path = d3.geoPath().projection(function(coordinates){
                console.log(coordinates[0], coordinates[1])
                return [
                    wrapIndex(coordinates[0], width),
                    wrapIndex(coordinates[1], height),
                ];
            });
            config['clip'] = false
        } else {
            projection.mode(value)
            path = d3.geoPath().projection(projection)
        }

        force.start()
    });

//    var clipChanger = gui.add(config, "clip").listen();
//    clipChanger.onChange(function(value) {
//        projection.clipAngle(value ? 90 : null)
//        force.start()
//    });
//
    var fl = gui.addFolder('Force Layout');
    fl.open()
//
//    var frictionChanger = fl.add(config, "friction", 0, 1);
//    frictionChanger.onChange(function(value) {
//        force.friction(value)
//        force.start()
//    });
//
    var linkDistanceChanger = fl.add(config, "linkDistance", 0, 400);
    linkDistanceChanger.onChange(function(value) {
        simulation.force("link").distance(value)
        simulation.alphaTarget(0.4).restart()
    });

    var linkStrengthChanger = fl.add(config, "linkStrength", 0, 1);
    linkStrengthChanger.onChange(function(value) {
        simulation.force("link").strength(value)
        //1 / Math.min(count(link.source), count(link.target))
        simulation.alphaTarget(0.4).restart()
    });

    var chargeChanger = fl.add(config,"charge", 0, 100);
    chargeChanger.onChange(function(value) {
        simulation.force("charge").strength(-value)
        simulation.alphaTarget(0.4).restart()
    });

//    var gravityChanger = fl.add(config,"gravity", 0, 1);
//    gravityChanger.onChange(function(value) {
//        simulation.force("center").strength(value)
//        simulation.alphaTarget(0.4).restart()
//    });
//
//    var thetaChanger = fl.add(config,"theta", 0, 1);
//    thetaChanger.onChange(function(value) {
//        force.theta(value)
//        force.start()
//    });

     // ------- Beginning of straight links
    var svg = d3.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height");


    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(function(d) { return d.name; })) // suspicious ?
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(width / 2, height / 2));

//    var force = d3.layout.force()
//            .linkDistance(config["linkDistance"])
//            .linkStrength(config["linkStrength"])
//            .gravity(config["gravity"])
//            .size([width, height])
//            .charge(-config["charge"]);

    d3.json("graph_links_min3.json", function(error, graph_links) {

        if (error) throw error;


        d3.json("graph_nodes_min3.json", function(error, graph_nodes) {

            var link = svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph_links)
                    .enter().append("line")
                    .attr("stroke-width", function(d) { return 1.5*(d.value-0.9); }); // originally Math.sqrt(d.value)

//            var node = svg.append("g")
//                    .attr("class", "nodes")
//                    .selectAll("circle")
//                    .data(graph_nodes)
//                    .enter().append("circle")
//                    .attr("r", function(d) { return Math.sqrt(2*d.uses); })
//                    .attr("fill", function(d) { return color(d.group); })
//                    .call(d3.drag()
//                    .on("start", dragstarted)
//                    .on("drag", dragged)
//                    .on("end", dragended));

            var node2 = svg.append("g")
                    .attr("class", "nodes")
                    .selectAll("image")
                    .data(graph_nodes)
                    .enter().append("image")
                    .attr("xlink:href", function(d) { return "font_pngs/"+d.image_url; })
                    .attr("width", function(d) { return 10*Math.sqrt(d.uses); })
                    .attr("height", 50) // max-height

            node2
                    .attr("x", function(d) { return -(this.getBBox().width/2);})
                    .attr("y", function(d) { return -(this.getBBox().height/2);})
                    .call(d3.drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended));


            // drag feature


//            node.append("title")
//                    .text(function(d) { return d.name; });
            node2.append("title")
                    .text(function(d) { return d.name; });

            simulation
                    .nodes(graph_nodes)
                    .on("tick", ticked);

            simulation.force("link")
                    .links(graph_links);

            function ticked() {
                link
                        .attr("x1", function(d) { return d.source.x; })
                        .attr("y1", function(d) { return d.source.y; })
                        .attr("x2", function(d) { return d.target.x; })
                        .attr("y2", function(d) { return d.target.y; });

//                node
//                      .attr("cx", function(d) { return d.x; })
//                      .attr("cy", function(d) { return d.y; });
                node2
                        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; }); // for the image

            }

//            var radius = 10;
            // BOUNDING BOX OPTION
//            function ticked() {
//                node.attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
//                        .attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });
//
//                link.attr("x1", function(d) { return d.source.x; })
//                        .attr("y1", function(d) { return d.source.y; })
//                        .attr("x2", function(d) { return d.target.x; })
//                        .attr("y2", function(d) { return d.target.y; });
//            }

        });
    });

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

</script>
