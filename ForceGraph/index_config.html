<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .links line {
        stroke: #999;
        /*stroke-opacity: 0.6;*/
    }

    /*.nodes circle {*/
    /*stroke: #fff;*/
    /*stroke-width: 1.5px;*/
    /*}*/

    .nodes image {
        -webkit-filter: invert(1);
        filter: invert(1);
    }

    /*#map1 {*/
    /*width:960px;*/
    /*height:100px; background:cyan;*/
    /*}*/
    /*#map2 {*/
    /*width:960px;*/
    /*height:100px; background:red;*/
    /*}*/
</style>


<!--<div id='map1'></div>-->
<!--<div id='map2'></div>-->
<body id="container" style="overflow: hidden">
<div id="searchbar" class="ui-widget">
    <input id="search">
    <button type="button" onclick="searchNode()">Search</button>
</div>
<svg id="viz"></svg>
</body>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
<script type='text/javascript' src="http://code.jquery.com/ui/1.11.0/jquery-ui.min.js"></script>
<link rel="stylesheet" type="text/css" href="jquery-ui-edited.css">
<link href="https://fonts.googleapis.com/css?family=Slabo+27px" rel="stylesheet">

<script>

    // -------- CONFIGURATION CONTROLLERS ----------
    var config = {
        "velocityDecay": .8,
        "linkStrength": 0.8,
        "linkDistance": 100,
        "charge": 150,
        "gravity": .1,
        "collision": 6,
        "links": true
    };
    var gui = new dat.GUI();

    var fl = gui.addFolder('Force Layout');

    fl.open()
    var velocityDecayChanger = fl.add(config, "velocityDecay", 0, 1);
    velocityDecayChanger.onChange(function (value) {
        simulation.velocityDecay(value);
        simulation.restart()
    });
    var linkDistanceChanger = fl.add(config, "linkDistance", 0, 400);
    linkDistanceChanger.onChange(function (value) {
        simulation.force("link").distance(value);
        simulation.alphaTarget(0.1).restart()
    });
    var linkStrengthChanger = fl.add(config, "linkStrength", 0, 1);
    linkStrengthChanger.onChange(function (value) {
        simulation.force("link").strength(value);
        //1 / Math.min(count(link.source), count(link.target))
        simulation.alphaTarget(0.1).restart()
    });
    var chargeChanger = fl.add(config, "charge", 30, 300);
    chargeChanger.onChange(function (value) {
        simulation.force("charge").strength(-value);
        simulation.alphaTarget(0.4).restart()
    });
    //    var thetaChanger = fl.add(config,"theta", 0, 1);
    //    thetaChanger.onChange(function(value) {
    //        force.theta(value)
    //        force.start()
    //    });
    var collisionChanger = fl.add(config, "collision", 0, 20);
    collisionChanger.onChange(function (value) {
        simulation.force("collide", d3.forceCollide().radius(function (d) {
            return value * Math.sqrt(d.uses);
        }).iterations(2));
        simulation.alphaTarget(0.4).restart()
    });


    // ------ Global variables -----------
    var default_link_opacity = 0.9;
    // color groups
    //var color = d3.scaleOrdinal(d3.schemeCategory20);


    // set SVG width, height to window size
    var w = window,
            d = document,
            e = d.documentElement,
            g = d.getElementsByTagName('body')[0],
            width = w.innerWidth || e.clientWidth || g.clientWidth,
            height = w.innerHeight || e.clientHeight || g.clientHeight;

    var svg = d3.select("svg")
            .attr("width", width)
            .attr("height", height);

    function updateWindow() {
        var width = w.innerWidth || e.clientWidth || g.clientWidth;
        var height = w.innerHeight || e.clientHeight || g.clientHeight;

        svg.attr("width", width).attr("height", height);
        backgrd.attr("width", width).attr("height", height);
    }
    window.onresize = updateWindow;


    // create a background to intercept events
    // (responds to mouse, even when transparent)
    var backgrd = svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .style("fill", "white")
            .style("opacity", 0.2)
            .style("pointer-events", "all")
            .on("click", unclick);

    var g = svg.append("g")
            .attr("class", "container");

    /////// ----------------------- FUNCTIONS ----------------


    //------------------------ ZOOM ------------------------

    function zoomed() {
//        console.log("zoomed trsfrm", d3.event.transform);
        g.attr("transform", "translate(" + d3.event.transform.x + "," + d3.event.transform.y + ")scale(" + d3.event.transform.k + ")");
    }

    var zoom = d3.zoom()
            .scaleExtent([0.2, 4])
            .on("zoom", zoomed);
    // look at zoom.extent and zoom.translateExtent
    svg.call(zoom); // why SVG and not g ?


    //------------------------ CLICK STUFF ----------------------

    // Copied from M. Bostock's d3 V3, since this function disappeared from V4.
    // https://groups.google.com/forum/#!topic/d3-js/86_jy82NNSY
    d3.rebind = function (target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function () {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }


    function center_node(d, zoomon) {
        // Moves clicked node to center ; if zoomon true, will also zoom to on node to make it readable

        if (zoomon) {
            var scale = 3; // change to adapt to font box size !
        } else {
            var scale = d3.zoomTransform(viz).k;
        }

        var dcx = (width / 2 - d.x * scale);
        var dcy = (height / 2 - d.y * scale);


        // effectively do the transform
        g.transition()
                .duration(2000)
                .attr("transform", "translate(" + dcx + "," + dcy + ")scale(" + scale + ")");

        // update zoom object to reflect the transform, and prevent "jumping" effect when click followed by panning
        d3.select(viz).transition().duration(2000)
                .call(zoom.transform, d3.zoomIdentity.translate(dcx, dcy).scale(scale));

        fadeOtherLinks(d.name);
//        console.log("center trsfrm", d3.zoomTransform(viz));
    }

    function strenghten_links_to_node(d) {

        var dcx = (width / 2 - d.x * scale);
        var dcy = (height / 2 - d.y * scale);

        // effectively do the transform
        g.transition()
                .duration(2000)
                .attr("transform", "translate(" + dcx + "," + dcy + ")scale(" + scale + ")");

        // update zoom object to reflect the transform, and prevent "jumping" effect when click followed by panning
        d3.select(viz).transition().duration(2000)
                .call(zoom.transform, d3.zoomIdentity.translate(dcx, dcy).scale(scale));

        fadeOtherLinks(d.name);
    }




    /////////---------------- FORCE SIMULATION -----------------


    var simulation = d3.forceSimulation()
            .velocityDecay(config.velocityDecay)
            .force("link", d3.forceLink()
                    .distance(config.linkDistance)
                    .strength(config.linkStrength)
                    .id(function (d) { return d.name;})) // suspicious ?
            .force("charge", d3.forceManyBody().strength(-config.charge))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide().radius(function (d) {
                return 4*Math.sqrt(d.uses);
            }).iterations(2));

    console.log(-config.charge);

    d3.json("Data/graph_links_reduced.json", function (error, graph_links) {
        if (error) throw error;

        d3.json("Data/graph_nodes_reduced.json", function (error, graph_nodes) {

            var links_on = true;
            var linksChanger = gui.add(config, "links").listen();
            linksChanger.onChange(function (value) {
                links_on = value;
                simulation.restart()
            });

            var link = g.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph_links)
                    .enter().append("line")

//            var node = g.append("g")
//                    .attr("class", "nodes")
//                    .selectAll("circle")
//                    .data(graph_nodes)
//                    .enter().append("circle")
//                    .attr("r", function(d) { return Math.sqrt(2*d.uses); })
//                    .attr("fill", function(d) { return color(d.group); })
//                    .call(d3.drag()
//                    .on("start", dragstarted)
//                    .on("drag", dragged)
//                    .on("end", dragended));

            var node2 = g.append("g")
                    .attr("class", "nodes")
                    .selectAll("image")
                    .data(graph_nodes)
                    .enter().append("image")
                    .attr("id", function (d) {
                        return d.name;
                    })
                    .attr("xlink:href", function (d) {
                        return "Fonts/originals_cleaned_scaled/" + d.image_url;
                    })
                    .attr("width", function (d) {
                        return 10 * Math.sqrt(d.uses);
                    })
                    .attr("height", 50) // max-height
                    .attr("x", function (d) {
                        return -(this.getBBox().width / 2);
                    })
                    .attr("y", function (d) {
                        return -(this.getBBox().height / 2);
                    })
                    .on("mouseover", function (d) {
                        d3.select(this).style("cursor", "pointer")
                    })
                    .on("mouseout", function (d) {
                        d3.select(this).style("cursor", "")
                    })
                    .on("click", function (d) {
                        center_node(d, false)
                    });


//    .on("click", function(d) {
//            var cc = clickcancel();
//            d3.select("#" + d.name).call(cc)
//            d3.select('#map').text(d3.select('#map').text() + 'click, ')
//            center_node(d, false)})


            // -------- SIMULATION -------

//            // drag feature
//            node2.call(d3.drag()
//                            .on("start", dragstarted)
//                            .on("drag", dragged)
//                            .on("end", dragended));

            node2.append("title")
                    .text(function (d) {
                        return d.name;
                    });

            simulation
                    .nodes(graph_nodes)
                    .on("tick", ticked);

            simulation.force("link")
                    .links(graph_links);

            function ticked() {
                link
                        .attr("x1", function (d) {
                            return d.source.x;
                        })
                        .attr("y1", function (d) {
                            return d.source.y;
                        })
                        .attr("x2", function (d) {
                            return d.target.x;
                        })
                        .attr("y2", function (d) {
                            return d.target.y;
                        })
                        .attr("stroke-opacity", links_on ? default_link_opacity : 0)
                        .attr("stroke-width", function (d) {
                            return 1.5 * (d.value - 0.9);
                        }); // originally Math.sqrt(d.value);

                node2
                        .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")";
                        }); // for the image
            }

            // --------- Autocomplete search bar (needs access to data) --------
            var optArray = [];

            for (var i = 0; i < graph_nodes.length - 1; i++) {
                optArray.push(graph_nodes[i].name);
            }

            optArray = optArray.sort();
            $(function () {
                $("#search").autocomplete({
                    source: optArray
                });
            });

        });
    });

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    function searchNode() {
        //find the node
        var selectedVal = document.getElementById('search').value;
        var node = svg.selectAll("image");

        if (selectedVal == "none") {
            return
            // sth (eg. flash red search box)
        } else {
            var selected = node.filter(function (d) {
                return d.name == selectedVal;
            });

            center_node(selected.datum(), true);
            fadeOtherLinks(selectedVal);
            // CAREFUL SELECTED IS ALL BUT SEARCHED... so change to "not selected"
//            selected.style("opacity", "0");
//            var link = svg.selectAll("line")
//            link.style("opacity", "0");
//            d3.selectAll("image, line").transition()
//                    .duration(5000)
//                    .style("opacity", 1);

        }
    }

    //select all links NOT related to the font name and fade
    function fadeOtherLinks(name) {
        var fade_links = svg.selectAll('line').filter(function (d) {
            return name !== d.source.name && name !== d.target.name;
        });

        svg.selectAll('line').transition().duration(1000).style('opacity', default_link_opacity);
        last_link_selection = fade_links;
        fade_links.transition().duration(1000).style('opacity', 0);
    }


    var last_link_selection = svg.selectAll('line'); // initialized full


    //    var cc = clickcancel();
    //    d3.selectAll('image').call(cc);
    //    d3.select('#map1').call(cc);
    //    d3.select('#map2').call(cc);
    //
    //    cc.on('click', function() {
    //        d3.select('#map1').text(d3.select('#map1').text() + 'click, ');
    //    });
    //
    //    cc.on('dblclick', function() {
    //        d3.select('#map2').text(d3.select('#map2').text() + 'dblclick, ');
    //    });

    function unclick() {

        last_link_selection
                .transition().duration(1000)
                .style("opacity", last_link_selection.style("opacity") == default_link_opacity ? 0 : default_link_opacity);
        console.log(last_link_selection.style("opacity") == default_link_opacity ? 0 : default_link_opacity);
    }


</script>
